{"version":3,"sources":["Components/Canvas.js","Components/life.js","App.js","serviceWorker.js","index.js"],"names":["Canvas","props","buildGrid","ctx","refs","canvas","getContext","i","height","rowPx","moveTo","lineTo","j","width","colPx","stroke","determinPosition","e","console","log","pos","getBoundingClientRect","xAxis","Math","floor","clientX","x","yAxis","clientY","y","boardClick","continueAnimation","this","onAnimFrame","board","l","length","fillRect","clearRect","ref","onClick","className","Component","life","newBoard","map","arr","rowL","colL","row","col","count","lRow","lCol","App","state","rowsPx","colsPx","running","generation","speed","speedTemp","handleInput","setState","target","name","value","blankBoard","tOrf","xIs","yIs","Array","fill","yes","rand","random","boardInput","loopGame","stop","setInterval","startGame","newGen","stopGame","clearInterval","clearBoard","randomBoard","changeSpeed","Container","size","run","Button","type","onChange","placeholder","styled","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ba32799d.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nclass Canvas extends Component {\n    constructor(props) {\n        super(props);\n\n        this.continueAnimation = true;\n    }\n    /**\n     * After the component has mounted\n     */\n    componentDidMount() {\n        // Request initial animation frame\n        // requestAnimationFrame((timestamp) => { this.onAnimFrame(timestamp); });\n        this.buildGrid();\n    }\n    componentDidUpdate(){\n        this.onAnimFrame();\n    }\n    /**\n     * When the component is about to unmount\n     */\n    // componentWillUnmount() {\n    //     // Stop animating\n    //     this.continueAnimation = false;\n    // }\n\n    /**\n     * Called every frame of animation\n     */\n    buildGrid = () => {\n        const ctx = this.refs.canvas.getContext('2d');\n        for(let i = 0; i <= this.props.height; i += this.props.rowPx){\n            ctx.moveTo(i, 0);\n            ctx.lineTo(i, this.props.height)\n            for(let j = 0 ; j <= this.props.width; j+= this.props.colPx){\n                ctx.moveTo(0, j);\n                ctx.lineTo(this.props.height, j)\n            }\n        }\n        ctx.stroke();\n        // ctx.fillRect(30, 0, 15, 15)\n    }\n\n    determinPosition = (e) => {\n        console.log(this.props.rowPx)\n        const pos = this.refs.canvas.getBoundingClientRect()\n        const xAxis = Math.floor((e.clientX - pos.x) / this.props.rowPx);\n        const yAxis = Math.floor((e.clientY - pos.y) / this.props.colPx);\n        // const ctx = this.refs.canvas.getContext('2d');\n        console.log(\"clientX - posX\", (e.clientX - pos.x));\n\n        \n        // ctx.fillRect(\n        //     e.clientX - pos.x - ((e.clientX - pos.x) % 15),\n        //     e.clientY - pos.y - ((e.clientY - pos.y) % 15),\n        //     15,\n        //     15\n        // );\n        this.props.boardClick(yAxis, xAxis)\n        // console.log(xAxis, yAxis);\n    }\n    onAnimFrame() {\n        // If desired, request another anim frame for later\n        // if (this.continueAnimation) {\n        //     requestAnimationFrame((timestamp) => { this.onAnimFrame(timestamp); });\n        // }\n        const ctx = this.refs.canvas.getContext('2d');\n        const board = this.props.board;\n        for(let i = 0, l = board.length; i < l; i++){\n            for(let j = 0, l = board.length; j < l; j++){\n                if(board[i][j]){\n                    ctx.fillRect(j * this.props.colPx + 1, i * this.props.rowPx + 1, this.props.colPx - 2, this.props.rowPx - 2)\n                }else{\n                    ctx.clearRect(j * this.props.colPx + 1, i * this.props.rowPx + 1, this.props.colPx - 2, this.props.rowPx - 2)\n                }\n            }\n        }\n        // this.buildGrid()\n    }\n\n    /**\n     * Render the canvas\n     */\n    render() {\n        return( \n            <canvas \n                ref=\"canvas\" \n                width={this.props.width} \n                height={this.props.height}\n                onClick={this.determinPosition}\n                className=\"canvas\"\n            />\n        );\n    }\n}\n\nexport default Canvas;","const life = (board) => {\n  // console.log(board);\n  const newBoard = board.map(arr => [...arr]);\n  const rowL = board.length;\n  const colL = board[0].length;\n  for(let row = 0; row < rowL; row++){\n    for(let col = 0; col < colL; col++){\n      let count = 0;\n      for(let lRow = -1; lRow < 2; lRow++){\n        for(let lCol = -1; lCol < 2; lCol++){\n          if(typeof board[row + lRow] !== 'undefined'){\n            if(typeof board[row + lRow][col + lCol] !== 'undefined'){\n              if(board[row + lRow][col + lCol]){\n                count++;\n              }\n            }\n          }\n        }\n      }\n      if(board[row][col]){\n        count--;\n      }\n      \n      if(board[row][col]){\n        if(count === 2 || count === 3){\n          newBoard[row][col] = true;\n        }else{\n          newBoard[row][col] = false;\n        }\n      }\n      if(!board[row][col] && count === 3){\n        newBoard[row][col] = true;\n      }\n      // console.log(\"count:\", count, \"Row:\", row, \"Col:\", col);\n    }\n  }\n\n  // console.log(newBoard)\n  return newBoard;\n};\n\nexport default life;","import React, { Component } from 'react';\nimport Canvas from './Components/Canvas';\nimport life from './Components/life';\nimport styled from \"styled-components\";\nimport './App.css';\n\nclass App extends Component {\n  state = {\n    width: 700,\n    height: 700,\n    rowsPx: 10,\n    colsPx: 10,\n    board: [],\n    running: false,\n    generation: 0,\n    speed: 20,\n    speedTemp:null,\n  }\n\n  componentDidMount(){\n    const newBoard = this.blankBoard();\n    this.setState({board: newBoard});\n    \n  }\n  handleInput = e => {\n    this.setState({ [e.target.name]: e.target.value})\n  }\n\n  blankBoard = (tOrf = false) => {\n    const xIs = Math.floor(this.state.width / this.state.colsPx);\n    const yIs = Math.floor(this.state.height / this.state.rowsPx); \n    const newBoard = Array(yIs).fill().map(() => Array(xIs).fill().map((yes) => {\n        let rand = false;\n        if(tOrf){\n        rand = Math.random() > 0.65;\n        }\n        return yes = rand;\n      }));\n    return newBoard;\n  }\n\n  boardInput = (row, col) => {\n    const newBoard = this.state.board.map(arr => [...arr]);\n    if(newBoard[row][col]){\n      newBoard[row][col] = false;\n    }else{\n      newBoard[row][col] = true;\n    }\n    this.setState({board: newBoard});\n  }\n\n  loopGame = () => {\n    if(!this.state.running){\n      const stop = setInterval(this.startGame, this.state.speed);\n      this.setState({\n        stop: stop,\n        running: true,\n      })\n    }\n  }\n  startGame = () => {\n    const newBoard = life(this.state.board);\n    console.log(newBoard)\n    let newGen = this.state.generation + 1; \n    this.setState({\n      board: newBoard,\n      generation: newGen,\n    });\n  };\n\n  stopGame = () => {\n    clearInterval(this.state.stop);\n    this.setState({\n      running: false,\n    });\n  }\n\n  clearBoard = () => {\n    const newBoard = this.blankBoard();\n    this.stopGame();\n    this.setState({\n      board: newBoard,\n      generation: 0,\n    });\n  }\n\n  randomBoard = () => {\n    const newBoard = this.blankBoard(true)\n    this.stopGame();\n    this.setState({\n      board: newBoard,\n      generation: 0,\n    });\n  }\n\n  changeSpeed = () => {\n    this.setState({\n      speed: this.state.speedTemp,\n      speedTemp: '',\n    })\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Container size={(this.state.width * 2.1) + \"px\"}>\n          <h1>Conways's Game of Life</h1>\n          <h3>Generation: {this.state.generation}</h3>\n          <Canvas \n            width={this.state.width} \n            height={this.state.width}\n            colPx={this.state.colsPx}\n            rowPx={this.state.rowsPx}\n            boardClick={this.boardInput}\n            run={this.state.running}\n            board={this.state.board}\n          />\n          <div>\n            <b>Game Rules</b>\n            <ul>\n              <li>If a cell is alive and it has exactly 2 or 3 living neigbors, it stays alive</li>\n              <li>If a cell is dead and it has exactly 3 living neigbors, it rises again</li>\n            </ul>\n            <Container size={(this.state.width) + \"px\"}>\n              <Button\n                onClick={this.randomBoard}>\n                Random\n              </Button>\n              <Button\n                onClick={this.loopGame}>\n                  Start\n              </Button>\n              <Button\n                onClick={this.stopGame}>\n                  Stop\n              </Button>\n              <Button\n                onClick={this.startGame}>\n                  One Gen\n              </Button>\n              <Button\n                onClick={this.clearBoard}>\n                  Clear\n              </Button>\n              <div>\n              <input \n                type=\"text\" \n                name=\"speedTemp\" \n                value={this.state.speedTemp} \n                onChange={this.handleInput}\n                placeholder={this.state.speed}/>\n              <Button\n                onClick={this.changeSpeed}>\n                  Change Speed\n              </Button>\n              </div>\n            </Container>\n          </div>\n        </Container>\n        </div>\n    );\n  }\n}\n\nconst Button = styled(\"button\")`\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border-radius: 3px;\n  bottom: 0;\n\n  :hover {\n    background-color: lightgray;\n  }\n  :active{\n    background-color: darkgray;\n  }\n  :focus{\n    outline: 0;\n  }  \n`\n\nconst Container = styled(\"div\")`\n  width: ${props => props.size};\n  display: flex;\n  justify-content: center;\n  flex-flow: row wrap;\n  align-items: center;\n\n  h1{\n    width: 100%;\n  }\n  h3{\n    width: 100%\n  }\n  ul{\n    text-align: left;\n  }\n`\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}